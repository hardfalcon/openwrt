From 432a43ac75e3b124fde2476458a199ceba12582f Mon Sep 17 00:00:00 2001
From: Christian Marangi <ansuelsmth@gmail.com>
Date: Sun, 12 Oct 2025 13:57:15 +0200
Subject: [PATCH] linkers: don't include absolue RPATH on cross-compiling

There is currently a reproducible problem when cross-compiling with the
inclusion of external shared library RPATH entry. Meson normally
includes RPATH entry to permit the usage of the tool in the build process
and later removes it on the intall phase. This might be ok and permits
creating reproducible build to some degree when building on host (as we
can expect the shared library are always placed on a standard directory
path and have a consistent RPATH)

This doesn't apply for cross-compilation scenario where the shared
library might be provided from an arbritrary directory to be later
packed in the final system (for example a squashfs image)

On top of this on cross-compilation on 99% of the scenario, it's not
really possible to run the just built tool for build usage as it
probably target a different arch (unless the project provide an
exe_wrapper).

To permit building REAL reproducible binary, add extra logic to skip the
inclusion of such library path in RPATH if we detect a cross-compilation
scenario and limit the inclusion of library path in RPATH only to
relative path (expected to be the ones specific to the building
binary/internal shared library) if we detect the binaries can't be run
on the host system (by the use of can_run_host_binaries() API).

Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
---
 mesonbuild/linkers/linkers.py | 62 +++++++++++++++++++++++++----------
 1 file changed, 45 insertions(+), 17 deletions(-)

--- a/mesonbuild/linkers/linkers.py
+++ b/mesonbuild/linkers/linkers.py
@@ -558,11 +558,11 @@ class TaskingStaticLinker(StaticLinker):
     def get_linker_always_args(self) -> T.List[str]:
         return ['-r']
 
-def prepare_rpaths(raw_rpaths: T.Tuple[str, ...], build_dir: str, from_dir: str) -> T.List[str]:
+def prepare_rpaths(env: Environment, raw_rpaths: T.Tuple[str, ...], build_dir: str, from_dir: str) -> T.List[str]:
     # The rpaths we write must be relative if they point to the build dir,
     # because otherwise they have different length depending on the build
     # directory. This breaks reproducible builds.
-    internal_format_rpaths = [evaluate_rpath(p, build_dir, from_dir) for p in raw_rpaths]
+    internal_format_rpaths = [evaluate_rpath(env, p, build_dir, from_dir) for p in raw_rpaths]
     ordered_rpaths = order_rpaths(internal_format_rpaths)
     return ordered_rpaths
 
@@ -579,11 +579,16 @@ def order_rpaths(rpath_list: T.List[str]
     return sorted(rpath_list, key=os.path.isabs)
 
 
-def evaluate_rpath(p: str, build_dir: str, from_dir: str) -> str:
+def evaluate_rpath(env: Environment, p: str, build_dir: str, from_dir: str) -> str:
     if p == from_dir:
         return '' # relpath errors out in this case
     elif os.path.isabs(p):
-        return p # These can be outside of build dir.
+        if env.can_run_host_binaries():
+            return p # These can be outside of build dir.
+        # Skip external library if we can't run binaries on host system.
+        # (cross-compilation and no exe_wrapper)
+        else:
+            return ''
     else:
         return os.path.relpath(os.path.join(build_dir, p), os.path.join(build_dir, from_dir))
 
@@ -711,7 +716,7 @@ class GnuLikeDynamicLinkerMixin(DynamicL
             return ([], set())
         args: T.List[str] = []
         origin_placeholder = '$ORIGIN'
-        processed_rpaths = prepare_rpaths(rpath_paths, build_dir, from_dir)
+        processed_rpaths = prepare_rpaths(env, rpath_paths, build_dir, from_dir)
         # Need to deduplicate rpaths, as macOS's install_name_tool
         # is *very* allergic to duplicate -delete_rpath arguments
         # when calling depfixer on installation.
@@ -721,9 +726,13 @@ class GnuLikeDynamicLinkerMixin(DynamicL
             rpath_dirs_to_remove.add(p.encode('utf8'))
         # Build_rpath is used as-is (it is usually absolute).
         if target.build_rpath != '':
-            all_paths.add(target.build_rpath)
-            for p in target.build_rpath.split(':'):
-                rpath_dirs_to_remove.add(p.encode('utf8'))
+            paths = target.build_rpath.split(':')
+            for p in paths:
+                # Only include relative paths if we can't run binaries on host system.
+                # (cross-compilation and no exe_wrapper)
+                if env.can_run_host_binaries() or not os.path.isabs(p):
+                    all_paths.add(p)
+                    rpath_dirs_to_remove.add(p.encode('utf8'))
         if extra_paths:
             all_paths.update(extra_paths)
 
@@ -883,10 +892,15 @@ class AppleDynamicLinker(PosixDynamicLin
         # @loader_path is the equivalent of $ORIGIN on macOS
         # https://stackoverflow.com/q/26280738
         origin_placeholder = '@loader_path'
-        processed_rpaths = prepare_rpaths(rpath_paths, build_dir, from_dir)
+        processed_rpaths = prepare_rpaths(env, rpath_paths, build_dir, from_dir)
         all_paths = mesonlib.OrderedSet([os.path.join(origin_placeholder, p) for p in processed_rpaths])
         if target.build_rpath != '':
-            all_paths.update(target.build_rpath.split(':'))
+            paths = target.build_rpath.split(':')
+            for p in paths:
+                # Only include relative paths if we can't run binaries on host system.
+                # (cross-compilation and no exe_wrapper)
+                if env.can_run_host_binaries() or not os.path.isabs(p):
+                    all_paths.add(p)
         if extra_paths:
             all_paths.update(extra_paths)
         for rp in all_paths:
@@ -1261,10 +1275,15 @@ class NAGDynamicLinker(PosixDynamicLinke
             return ([], set())
         args: T.List[str] = []
         origin_placeholder = '$ORIGIN'
-        processed_rpaths = prepare_rpaths(rpath_paths, build_dir, from_dir)
+        processed_rpaths = prepare_rpaths(env, rpath_paths, build_dir, from_dir)
         all_paths = mesonlib.OrderedSet([os.path.join(origin_placeholder, p) for p in processed_rpaths])
         if target.build_rpath != '':
-            all_paths.add(target.build_rpath)
+            paths = target.build_rpath.split(':')
+            for p in paths:
+                # Only include relative paths if we can't run binaries on host system.
+                # (cross-compilation and no exe_wrapper)
+                if env.can_run_host_binaries() or not os.path.isabs(p):
+                    all_paths.add(p)
         if extra_paths:
             all_paths.update(extra_paths)
         for rp in all_paths:
@@ -1517,15 +1536,19 @@ class SolarisDynamicLinker(PosixDynamicL
         rpath_paths = target.determine_rpath_dirs()
         if not rpath_paths and not target.install_rpath and not target.build_rpath and not extra_paths:
             return ([], set())
-        processed_rpaths = prepare_rpaths(rpath_paths, build_dir, from_dir)
+        processed_rpaths = prepare_rpaths(env, rpath_paths, build_dir, from_dir)
         all_paths = mesonlib.OrderedSet([os.path.join('$ORIGIN', p) for p in processed_rpaths])
         rpath_dirs_to_remove: T.Set[bytes] = set()
         for p in all_paths:
             rpath_dirs_to_remove.add(p.encode('utf8'))
         if target.build_rpath != '':
-            all_paths.add(target.build_rpath)
-            for p in target.build_rpath.split(':'):
-                rpath_dirs_to_remove.add(p.encode('utf8'))
+            paths = target.build_rpath.split(':')
+            for p in paths:
+                # Only include relative paths if we can't run binaries on host system.
+                # (cross-compilation and no exe_wrapper)
+                if env.can_run_host_binaries() or not os.path.isabs(p):
+                    all_paths.add(p)
+                    rpath_dirs_to_remove.add(p.encode('utf8'))
         if extra_paths:
             all_paths.update(extra_paths)
 
@@ -1591,7 +1614,12 @@ class AIXDynamicLinker(PosixDynamicLinke
         if target.install_rpath != '':
             all_paths.add(target.install_rpath)
         if target.build_rpath != '':
-            all_paths.add(target.build_rpath)
+            paths = target.build_rpath.split(':')
+            for p in paths:
+                # Only include relative paths if we can't run binaries on host system.
+                # (cross-compilation and no exe_wrapper)
+                if env.can_run_host_binaries() or not os.path.isabs(p):
+                    all_paths.add(p)
         for p in target.determine_rpath_dirs():
             all_paths.add(os.path.join(build_dir, p))
         # We should consider allowing the $LIBPATH environment variable
